Docker 
	Docker is one of the tools that used the idea of the isolated resources to 
	create a container that allows applications to be packaged with all the 
	dependencies installed and ran wherever we wanted.
	
	Docker can only run on Linux machines this means I cant install Dokcer directly on Windows or any other OS.
	If I want install Docker on windows then I need to run a Linux VM in windows on top that I need to run Docker.

Virtualization (VM)
	- VM is way of running virtual OS on top a host OS using a special software called Hyperviser.
	- VM directly shares the harware of the host OS. 

					VM 					vs 			Containerisation 
	1. Virtualization at hardware level  		1. Virtualization at OS level 
	2. Heavyweight - consume more host 			2. Lightweight
	   resources 	
	3. VM useses hypervisor 					3. containerisation tool is used 
	4. limited performace - Boot up time        4. Native performace - usualy boot 
		is more which is in minutes 			   fast in seconds.
	5. Cosumes more storage 					5. Shres OS storage means only uses 
												   required storage.
	6. Supports all OS 							6. Supports on Linux

host machine 
	This is the machine in which docker is running 
	
Docker image 

	To list images 
		docker images
		
	To download images from docker hub 
		docker pull <image_name>:<tag>

		note: The default tag will be always latest.
			  if we wont specify any tag latest will be considered 	
			  
	To connect to your docker hub account 
		docker login 

	To pull a image from your repo 
		docoker pull <username>/<image_name>:<tag>	
		
		ex: docker pull harshajain/my_ubuntu
		
	To push a image to your repo 

		1. Create a tag which matches your repo syntax 
			docker tag <old_name> <new_name>
			
			ex: docker tag ubuntu:22.10 harshajain/test:1.0
		
		2. Push the image 	
			docoker push <username>/<image_name>:<tag>	
		
			ex: docker push harshajain/test:1.0	
		
Docker container 
	A container is a set of isolated processes and resources. Linux achieves 
	this by using namespaces, which allows processes to access only resources 
	in that particular namespace, which allows having a process tree means set 
	of processes that is completely independent of the rest of the systems processes.
	
	Docker definition: A container is a standard unit of software that packages 
	up code and all its dependencies so the application runs quickly and reliably 
	from one computing environment to another.
	
	To list running containers 
		docker ps 
			(or)
		docker container ls 
	
	To list all containers
		docker ps -a 
	
	To list all stopped conatainers
		docker ps -a --filter status=exited
		
	To delete one or more container 	
		docker rm <conainter_id1> <conainter_id2> .... 
		
		To delete a running container 
			1. Forcefully - docker rm -f <conainter_id>
			2. Grace fully - docker rm $(docker stop <conainter_id>) 
											(or)
							 docker stop <conainter_id> | xargs -I{} docker rm "{}"						
				
	To delete all stopped/exited containers 
		docker rm $(docker ps -aq --filter status=exited)	
					(or)
		docker container prune
		
	To run a command inside a conatainer 
		docker exec -it <container_id> <command>
		
	To check the logs of conatainers 
		docker logs <container_id>

	To login / get inside a containre 
		docker attach <container_ID>  
				(safe exit <ctrl>+qp)
					(OR)
		docker exec -it <container_ID> /bin/bash		
	
	To create a container from a docker image 
		docker run -it -d --name <conainter_name> <image>:<tag> <run_time_command>
		
		-it - Interactive Terminal (tty) 
		-d - deatached mode (when ever we create a container it will auto login to avoid this 
			we can create a container in detached mode)
		--name used to provide user defined conatainer name
		
		Note: Always use the options before <image>:<tag> <run_time_command>
		
		ex: docker run -it -d --name my_jenkins -p 8080:8080 -p 50000:50000 jenkins/jenkins
		
Assignment: work with docker image and container commands
			Try to create a jenkins container (jenkins/jenkins:lts)		
	
	docker commit 
	docker export 
	docker import 
	docker save 
	
Docker custom image / Dockerfile
	Dockerfile
		Dockerfile is used to create custom images by using any stock image or other image as base image.
		In Dockerfile we can write some set of instructions to update any image.
	
		To create image from Dockerfile
			docker build -t my_ubuntu .
	
	FROM ubuntu
		FROM is the first instruction in the every Dockerfile
		FROM is used to specify the base image on top which all the other 
			instruction will run in the same Dockerfile.
			
		FROM <image_name>:<tag>
		
	RUN 
		Normal shell command or the commands supported by the base image are executed using this instruction.
		we can have n number of RUN in a single Dockerfile.
		
		Normal command format 
			RUN <command>
			
		exec format 
			RUN ['<command>','<param1>','<param2>']	
			RUN ['apt','update']	
			RUN ['apt','install','-y','git']	
			RUN ['ls','-lrt']	 
			
	ENV 
		- This instruction is used to set the environment variable inside the container.
		
		ENV <variable_name> <value>
		ENV <variable_name>=<value>
		
		multiple 
		ENV <variable_name>=<value> <variable_name>=<value> <variable_name>=<value> ....
		
		To create environment variables at run time 
			- using -e or --env option at the runtime we can create env variables 
			- For multiple variables use multiple -e 

		ex:	docker run .... -e <variable_name>=<value> -e <variable_name>=<value> ....	
		
		The best way to load multiple env variable is using env file 
			using --env-file <file_path> at the runtime (with docker run command) we can 
			load the env file containing n number variables. 
		
		
	COPY and ADD 
		- Both copy and add instruction is used to copy files and directories from host machine to the image.
		- The source path to copy files should always be evaluted with reference to Dockerfile.
		
		ADD supports extra source formats 
			- If the source is a compressed file add will automatically 
			  uncompresses it to the destination.
			- If the source is a link to a downloadable file it will download 
			  to the destination.
			  
		COPY <source_path_from_build_context> <destination_inside_image>	  
		ADD <source_path_from_build_context> <destination_inside_image>	  
		
		
	CMD and ENTRYPOINT
		shell format 
			CMD "ls -lrt"
			ENTRYPOINT "ls -lrt"
			
		EXEC Format
			CMD ["ls","-l","-rt"]
			ENTRYPOINT ["ls","-lrt"]
			
		- Both CMD and ENTRYPOINT are used to define the execution command of the container which will be created 
		  from this image.
		- If we use multiple CMD or ENTRYPOINT in the same Dockerfile only the latest one will be considered 
		  and all the other CMD or ENTRYPOINT will be ignored.	
		- If we use both CMD and ENTRYPOINT in the same Dockerfile, ENTRYPOINT will get the 
		  higest priority and the command of CMD will become as argumetns to ENTRYPOINT	
		  
		 Difference  
		  -	CMD command can be overridden at the runtime.	
		  - ENTRYPOINT can't be overridden at the runtime but the runtime command
		    will become parameters to ENTRYPOINT command.
		  
		Note: Q. Can we override ENTRYPOINT 
				 Yes, after docker 1.6 version docker has given option to over
					  Entrypoint command at the runtime using --entrypoint 
					  
Docker Volumes
 	- As the layers inside the image are readonly which means once the image is created 
	  we cannot change/edit so we cannot put the conatainer data in image.
	- Container create a top most RW layer and all the runtime data is saved here. 
	- Container layer is temparary layer, If we loose the container we loose data. so
	  to retain/persist the container runtime data we need docker volumes.

	Bind Mounts 
		- we can mount host machine filesystem (files and directories) to the container
		
			docker run -v <host_path>:<container_path>
	
		
	
				